# Plan: Fix HCL Variable Block Schema Mismatch

## Task Description

Fix the regression where `generator.go` produces HCL `variable` blocks that the parser cannot decode. The generator creates Terraform-style variable blocks with nested attributes (`type`, `sensitive`, `env`), but `types.go` defines `Variables` as `map[string]string` with attribute syntax. This causes deployment failures with error: "Unsupported block type; Blocks of type 'variable' are not expected here."

## Objective

Enable the HCL parser to correctly decode variable blocks generated by `generator.go`, allowing registry credentials to flow through `var.registry_username` and `var.registry_password` references during deployment.

## Problem Statement

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           SCHEMA MISMATCH                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Generator Output (generator.go:87-96)    Parser Schema (types.go:15)      │
│  ────────────────────────────────────     ────────────────────────────     │
│                                                                             │
│  variable "registry_username" {           Variables map[string]string      │
│    type = string                            `hcl:"variable,optional"`      │
│    sensitive = true                                                         │
│    env = ["REGISTRY_USERNAME"]            ← Expects ATTRIBUTE syntax,      │
│  }                                          NOT BLOCK syntax!              │
│                                                                             │
│  Registry stanza uses:                                                      │
│    username = var.registry_username                                         │
│    password = var.registry_password                                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

The error occurs at line 43 of generated `cloudstation.hcl` where the first `variable` block appears.

## Solution Approach

Implement proper HCL2 variable block support in the parser schema, then add variable resolution logic to populate the EvalContext with resolved values before expression evaluation. This follows HashiCorp's HCL2 patterns used in Terraform and Waypoint.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           SOLUTION FLOW                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. Parse HCL file (first pass - extract variable blocks)                  │
│                          ↓                                                  │
│  2. For each variable block with `env` field:                              │
│     - Read environment variable value                                       │
│     - Build variables map: {"registry_username": "actual_value"}           │
│                          ↓                                                  │
│  3. Create EvalContext with resolved variables                             │
│     - NewEvalContext(resolvedVars)                                         │
│                          ↓                                                  │
│  4. Decode full HCL body with context                                      │
│     - var.registry_username now resolves to actual value                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Relevant Files

### Core Files to Modify

- `internal/config/types.go` (lines 4-16)
  - Add `VariableConfig` struct for variable block schema
  - Change `Variables` field from `map[string]string` to `[]*VariableConfig`
  - Update HCL tag from `hcl:"variable,optional"` to `hcl:"variable,block"`

- `internal/config/parser.go` (lines 19-52, 194-205)
  - Add two-pass parsing: first extract variables, then decode with context
  - Add `resolveVariables()` function to read env vars based on variable definitions
  - Update `NewEvalContext()` call to pass resolved variables

- `internal/hclfunc/context.go` (lines 34-51)
  - Ensure `var` namespace is properly exposed in EvalContext for `var.X` syntax
  - May need to wrap variables in a `var` object for proper HCL2 variable resolution

### Test Files to Update

- `internal/config/parser_test.go`
  - Add tests for parsing HCL with variable blocks
  - Add tests for env var resolution via `env` field
  - Add tests for `var.X` reference resolution

- `internal/hclgen/generator_test.go`
  - Add round-trip test: generate HCL → parse → validate
  - Ensure generated HCL is parseable by updated parser

- `internal/hclgen/registry_test.go`
  - Verify variable blocks are correctly generated
  - Test credential variable references work end-to-end

### Reference Files (Read-Only)

- `internal/hclgen/generator.go` (lines 81-97, 207-211)
  - Understand variable block generation and var.X references

- `internal/dispatch/handlers.go` (lines 258-291)
  - Understand config loading flow in deployment

- `builtin/docker/plugin.go` (lines 451-462)
  - Understand how registry plugin uses credentials

## Implementation Phases

### Phase 1: Foundation - Schema Update

Update the type definitions to support HCL variable blocks with proper struct tags.

### Phase 2: Core Implementation - Parser Enhancement

Implement two-pass parsing with variable resolution and EvalContext population.

### Phase 3: Integration & Polish

Add comprehensive tests and validate end-to-end deployment flow.

## Step by Step Tasks

IMPORTANT: Execute every step in order, top to bottom.

### 1. Add VariableConfig Struct to types.go

- Open `internal/config/types.go`
- Add new struct after line 16:
```go
// VariableConfig represents an HCL variable block definition
type VariableConfig struct {
    // Name is the variable name (block label)
    Name string `hcl:"name,label"`

    // Type is the variable type (string, number, bool, etc.)
    Type string `hcl:"type,optional"`

    // Sensitive marks the variable as sensitive (suppresses logging)
    Sensitive bool `hcl:"sensitive,optional"`

    // Default is the default value if not provided
    Default string `hcl:"default,optional"`

    // Env is a list of environment variable names to check for value
    Env []string `hcl:"env,optional"`

    // Description documents the variable purpose
    Description string `hcl:"description,optional"`
}
```

### 2. Update Config Struct in types.go

- Modify the `Variables` field in `Config` struct (line 15):
```go
// Before:
Variables map[string]string `hcl:"variable,optional"`

// After:
Variables []*VariableConfig `hcl:"variable,block"`
```

### 3. Add Variable Resolution Function to parser.go

- Add new function after `processEnvVars()` (around line 117):
```go
// resolveVariables resolves variable values from their definitions
// It checks environment variables specified in the Env field
func resolveVariables(variables []*VariableConfig) map[string]string {
    resolved := make(map[string]string)

    for _, v := range variables {
        if v == nil {
            continue
        }

        var value string

        // Check environment variables in order
        for _, envName := range v.Env {
            if envVal := os.Getenv(envName); envVal != "" {
                value = envVal
                break
            }
        }

        // Fall back to default if no env var found
        if value == "" && v.Default != "" {
            value = v.Default
        }

        resolved[v.Name] = value
    }

    return resolved
}
```

### 4. Implement Two-Pass Parsing in parser.go

- Modify `ParseFile()` function to use two-pass approach:
```go
func ParseFile(path string) (*Config, error) {
    absPath, err := filepath.Abs(path)
    if err != nil {
        return nil, fmt.Errorf("failed to resolve path %s: %w", path, err)
    }

    if _, err := os.Stat(absPath); os.IsNotExist(err) {
        return nil, fmt.Errorf("configuration file not found: %s", absPath)
    }

    parser := hclparse.NewParser()
    file, diags := parser.ParseHCLFile(absPath)
    if diags.HasErrors() {
        return nil, fmt.Errorf("failed to parse HCL file: %s", diags.Error())
    }

    // PASS 1: Decode with empty context to extract variable definitions
    var partialConfig Config
    emptyCtx := hclfunc.NewEvalContext(nil)
    // Use PartialContent to allow unknown attributes during first pass
    diags = gohcl.DecodeBody(file.Body, emptyCtx, &partialConfig)
    // Note: We expect some diagnostics here due to unresolved var.X references
    // Filter for only variable-related errors

    // Resolve variables from their definitions
    resolvedVars := resolveVariables(partialConfig.Variables)

    // PASS 2: Re-decode with resolved variables in context
    var config Config
    evalCtx := hclfunc.NewEvalContextWithVars(resolvedVars)
    diags = gohcl.DecodeBody(file.Body, evalCtx, &config)
    if diags.HasErrors() {
        return nil, fmt.Errorf("failed to decode configuration: %s", diags.Error())
    }

    if err := processEnvVars(&config); err != nil {
        return nil, fmt.Errorf("failed to process environment variables: %w", err)
    }

    return &config, nil
}
```

### 5. Add NewEvalContextWithVars to context.go

- Add new function in `internal/hclfunc/context.go`:
```go
// NewEvalContextWithVars creates an evaluation context with variables
// exposed under the 'var' namespace for HCL2 variable reference syntax
func NewEvalContextWithVars(variables map[string]string) *hcl.EvalContext {
    // Convert string variables to cty.Value
    varMap := make(map[string]cty.Value)
    for k, v := range variables {
        varMap[k] = cty.StringVal(v)
    }

    // Create 'var' object to hold all variables
    // This enables var.registry_username syntax
    varsObject := cty.ObjectVal(varMap)

    return &hcl.EvalContext{
        Variables: map[string]cty.Value{
            "var": varsObject,
        },
        Functions: Functions(),
    }
}
```

### 6. Update Existing NewEvalContext Function

- Modify `NewEvalContext()` in context.go to also support var namespace:
```go
func NewEvalContext(variables map[string]string) *hcl.EvalContext {
    if variables == nil || len(variables) == 0 {
        return &hcl.EvalContext{
            Functions: Functions(),
        }
    }

    // Use the new function for consistency
    return NewEvalContextWithVars(variables)
}
```

### 7. Add Import for os Package in parser.go

- Ensure `os` is imported for `os.Getenv()` calls:
```go
import (
    "fmt"
    "os"
    "path/filepath"
    // ... other imports
)
```

### 8. Add Unit Tests for Variable Block Parsing

- Create test cases in `internal/config/parser_test.go`:
```go
func TestParseVariableBlocks(t *testing.T) {
    tests := []struct {
        name     string
        hcl      string
        envVars  map[string]string
        wantVars map[string]string
    }{
        {
            name: "variable with env fallback",
            hcl: `
project = "test"

variable "registry_username" {
  type = string
  sensitive = true
  env = ["REGISTRY_USERNAME"]
}

app "test" {
  build {
    use = "railpack"
  }
  deploy {
    use = "noop"
  }
}
`,
            envVars:  map[string]string{"REGISTRY_USERNAME": "testuser"},
            wantVars: map[string]string{"registry_username": "testuser"},
        },
        {
            name: "variable with default",
            hcl: `
project = "test"

variable "port" {
  type = string
  default = "8080"
}

app "test" {
  build { use = "railpack" }
  deploy { use = "noop" }
}
`,
            envVars:  nil,
            wantVars: map[string]string{"port": "8080"},
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Set env vars
            for k, v := range tt.envVars {
                os.Setenv(k, v)
                defer os.Unsetenv(k)
            }

            cfg, err := ParseBytes([]byte(tt.hcl), "test.hcl")
            if err != nil {
                t.Fatalf("parse failed: %v", err)
            }

            resolved := resolveVariables(cfg.Variables)
            for k, want := range tt.wantVars {
                if got := resolved[k]; got != want {
                    t.Errorf("variable %q = %q, want %q", k, got, want)
                }
            }
        })
    }
}
```

### 9. Add Round-Trip Test for Generator Output

- Add test in `internal/hclgen/generator_test.go`:
```go
func TestGenerateConfig_RoundTrip(t *testing.T) {
    // Set up test credentials in environment
    os.Setenv("REGISTRY_USERNAME", "testuser")
    os.Setenv("REGISTRY_PASSWORD", "testpass")
    defer os.Unsetenv("REGISTRY_USERNAME")
    defer os.Unsetenv("REGISTRY_PASSWORD")

    params := DeploymentParams{
        JobID:        "test-app",
        BuilderType:  "railpack",
        DeployType:   "nomad-pack",
        ImageName:    "test-app",
        ImageTag:     "latest",
        DisablePush:  false,
    }

    // Generate HCL
    hclContent, err := GenerateConfig(params)
    if err != nil {
        t.Fatalf("GenerateConfig failed: %v", err)
    }

    // Parse it back
    cfg, err := config.ParseBytes([]byte(hclContent), "cloudstation.hcl")
    if err != nil {
        t.Fatalf("ParseBytes failed: %v\nHCL content:\n%s", err, hclContent)
    }

    // Verify structure
    if cfg.Project != "test-app" {
        t.Errorf("project = %q, want %q", cfg.Project, "test-app")
    }
    if len(cfg.Apps) != 1 {
        t.Errorf("len(apps) = %d, want 1", len(cfg.Apps))
    }
    if len(cfg.Variables) != 2 {
        t.Errorf("len(variables) = %d, want 2", len(cfg.Variables))
    }
}
```

### 10. Validate the Complete Flow

- Run all tests to ensure changes work:
```bash
cd /root/code/cs-monorepo/apps/cloudstation-orchestrator
go test ./internal/config/... -v
go test ./internal/hclgen/... -v
go test ./internal/hclfunc/... -v
```

- Build the binary:
```bash
go build -o cs ./cmd/cloudstation/
```

- Test with a real deployment payload (dry run if possible)

## Testing Strategy

### Unit Tests

1. **Parser Tests** (`parser_test.go`)
   - Parse HCL with single variable block
   - Parse HCL with multiple variable blocks
   - Resolve variable from env var
   - Resolve variable from default when env not set
   - Priority: env var over default
   - Empty env array with default
   - Variable used in expression (var.X)

2. **Context Tests** (`context_test.go`)
   - NewEvalContextWithVars creates proper var namespace
   - var.X references resolve correctly
   - Empty variables map doesn't break context

3. **Generator Round-Trip Tests** (`generator_test.go`)
   - Generated HCL can be parsed back
   - Variable blocks are correctly formed
   - var.X references in registry stanza work

### Integration Tests

1. **End-to-End Deployment Test**
   - Set REGISTRY_USERNAME and REGISTRY_PASSWORD env vars
   - Call HandleDeployRepository with test params
   - Verify config loads without error
   - Verify registry plugin receives credentials

### Edge Cases

- Variable block with no env field
- Variable block with empty env array
- Variable referencing undefined env var (should use default or empty)
- Multiple variables with same env var (first wins)
- Sensitive flag handling (no logging of values)

## Acceptance Criteria

- [ ] HCL files with `variable` blocks parse without error
- [ ] Variables with `env` field resolve from environment variables
- [ ] Variables with `default` field use default when env not set
- [ ] `var.registry_username` and `var.registry_password` references work in registry stanza
- [ ] All existing tests pass
- [ ] New tests cover variable block parsing and resolution
- [ ] Round-trip test (generate → parse) passes
- [ ] Real deployment with registry push succeeds

## Validation Commands

Execute these commands to validate the task is complete:

```bash
# Run all config package tests
cd /root/code/cs-monorepo/apps/cloudstation-orchestrator
go test ./internal/config/... -v -run TestParse

# Run hclfunc tests
go test ./internal/hclfunc/... -v

# Run generator tests including round-trip
go test ./internal/hclgen/... -v -run TestGenerateConfig

# Build to ensure no compilation errors
go build -o cs ./cmd/cloudstation/

# Run full test suite
go test ./... -v

# Verify no regressions in registry tests
go test ./internal/hclgen/... -v -run TestRegistry
```

## Notes

- The `gohcl.DecodeBody` function may emit diagnostics for unresolved `var.X` references during the first pass. These can be filtered or ignored since we're only extracting variable definitions in pass 1.

- Consider using `hclsyntax.ParseConfig` for lighter-weight first pass if performance is a concern.

- The `sensitive = true` flag in variable blocks is informational and used by logging/debugging tools. The parser should preserve this but doesn't need to act on it.

- This implementation follows patterns from Terraform's variable handling but simplified for CloudStation's use case.

- Existing `env("VAR")` function syntax continues to work alongside the new `var.X` syntax - they serve different purposes (direct env access vs declared variables with defaults).
